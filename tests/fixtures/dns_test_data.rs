//! Test fixtures and sample DNS packet data for testing

use std::collections::HashMap;

/// Sample DNS packets captured from real servers
pub struct DnsTestData;

impl DnsTestData {
    /// Get a sample A record response packet
    pub fn a_record_google() -> Vec<u8> {
        vec![
            // Header
            0x12, 0x34, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            // Question: google.com A
            0x06, b'g', b'o', b'o', b'g', b'l', b'e',
            0x03, b'c', b'o', b'm',
            0x00, 0x00, 0x01, 0x00, 0x01,
            // Answer
            0xC0, 0x0C, 0x00, 0x01, 0x00, 0x01,
            0x00, 0x00, 0x01, 0x2C, 0x00, 0x04,
            0x8E, 0xFA, 0xBD, 0x0E, // 142.250.189.14
        ]
    }

    /// Get a sample AAAA record response packet
    pub fn aaaa_record_ipv6() -> Vec<u8> {
        vec![
            // Header
            0x45, 0x67, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            // Question
            0x07, b'e', b'x', b'a', b'm', b'p', b'l', b'e',
            0x03, b'c', b'o', b'm',
            0x00, 0x00, 0x1C, 0x00, 0x01,
            // Answer
            0xC0, 0x0C, 0x00, 0x1C, 0x00, 0x01,
            0x00, 0x00, 0x0E, 0x10, 0x00, 0x10,
            0x26, 0x06, 0x28, 0x00, 0x02, 0x20, 0x00, 0x01,
            0x02, 0x48, 0x18, 0x93, 0x25, 0xc8, 0x19, 0x46,
        ]
    }

    /// Get a sample MX record response packet
    pub fn mx_records() -> Vec<u8> {
        vec![
            // Header
            0x11, 0x22, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
            // Question
            0x07, b'e', b'x', b'a', b'm', b'p', b'l', b'e',
            0x03, b'c', b'o', b'm',
            0x00, 0x00, 0x0F, 0x00, 0x01,
            // Answer 1: Priority 10
            0xC0, 0x0C, 0x00, 0x0F, 0x00, 0x01,
            0x00, 0x00, 0x0E, 0x10, 0x00, 0x11,
            0x00, 0x0A,
            0x04, b'm', b'a', b'i', b'l',
            0x07, b'e', b'x', b'a', b'm', b'p', b'l', b'e',
            0x03, b'c', b'o', b'm',
            0x00,
            // Answer 2: Priority 20
            0xC0, 0x0C, 0x00, 0x0F, 0x00, 0x01,
            0x00, 0x00, 0x0E, 0x10, 0x00, 0x13,
            0x00, 0x14,
            0x06, b'b', b'a', b'c', b'k', b'u', b'p',
            0x07, b'e', b'x', b'a', b'm', b'p', b'l', b'e',
            0x03, b'c', b'o', b'm',
            0x00,
        ]
    }

    /// Get a sample TXT record response packet
    pub fn txt_record_spf() -> Vec<u8> {
        vec![
            // Header
            0x33, 0x44, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            // Question
            0x07, b'e', b'x', b'a', b'm', b'p', b'l', b'e',
            0x03, b'c', b'o', b'm',
            0x00, 0x00, 0x10, 0x00, 0x01,
            // Answer
            0xC0, 0x0C, 0x00, 0x10, 0x00, 0x01,
            0x00, 0x00, 0x01, 0x2C, 0x00, 0x25,
            0x24,
            b'v', b'=', b's', b'p', b'f', b'1', b' ',
            b'i', b'n', b'c', b'l', b'u', b'd', b'e', b':', b'_',
            b's', b'p', b'f', b'.', b'g', b'o', b'o', b'g', b'l', b'e', b'.', b'c', b'o', b'm',
            b' ', b'~', b'a', b'l', b'l',
        ]
    }

    /// Get a sample NS record response packet
    pub fn ns_records() -> Vec<u8> {
        vec![
            // Header
            0x77, 0x88, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
            // Question
            0x07, b'e', b'x', b'a', b'm', b'p', b'l', b'e',
            0x03, b'c', b'o', b'm',
            0x00, 0x00, 0x02, 0x00, 0x01,
            // Answer 1
            0xC0, 0x0C, 0x00, 0x02, 0x00, 0x01,
            0x00, 0x01, 0x51, 0x80, 0x00, 0x06,
            0x03, b'n', b's', b'1',
            0xC0, 0x0C,
            // Answer 2
            0xC0, 0x0C, 0x00, 0x02, 0x00, 0x01,
            0x00, 0x01, 0x51, 0x80, 0x00, 0x06,
            0x03, b'n', b's', b'2',
            0xC0, 0x0C,
        ]
    }

    /// Get a sample CNAME record response packet
    pub fn cname_record() -> Vec<u8> {
        vec![
            // Header
            0x99, 0xAA, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            // Question
            0x03, b'w', b'w', b'w',
            0x07, b'e', b'x', b'a', b'm', b'p', b'l', b'e',
            0x03, b'c', b'o', b'm',
            0x00, 0x00, 0x05, 0x00, 0x01,
            // Answer
            0xC0, 0x0C, 0x00, 0x05, 0x00, 0x01,
            0x00, 0x00, 0x01, 0x2C, 0x00, 0x02,
            0xC0, 0x10, // Pointer to example.com
        ]
    }

    /// Get a sample SOA record response packet
    pub fn soa_record() -> Vec<u8> {
        vec![
            // Header
            0x55, 0x66, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            // Question
            0x07, b'e', b'x', b'a', b'm', b'p', b'l', b'e',
            0x03, b'c', b'o', b'm',
            0x00, 0x00, 0x06, 0x00, 0x01,
            // Answer
            0xC0, 0x0C, 0x00, 0x06, 0x00, 0x01,
            0x00, 0x00, 0x15, 0x18, 0x00, 0x26,
            0x03, b'n', b's', b'1', 0xC0, 0x0C,
            0x05, b'a', b'd', b'm', b'i', b'n', 0xC0, 0x0C,
            0x78, 0x49, 0x52, 0x25, // Serial
            0x00, 0x00, 0x1C, 0x20, // Refresh
            0x00, 0x00, 0x0E, 0x10, // Retry
            0x00, 0x12, 0x75, 0x00, // Expire
            0x00, 0x00, 0x00, 0x78, // Minimum
        ]
    }

    /// Get a sample SRV record response packet
    pub fn srv_record() -> Vec<u8> {
        vec![
            // Header
            0xBB, 0xCC, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            // Question
            0x04, b'_', b's', b'i', b'p',
            0x04, b'_', b't', b'c', b'p',
            0x07, b'e', b'x', b'a', b'm', b'p', b'l', b'e',
            0x03, b'c', b'o', b'm',
            0x00, 0x00, 0x21, 0x00, 0x01,
            // Answer
            0xC0, 0x0C, 0x00, 0x21, 0x00, 0x01,
            0x00, 0x00, 0x0E, 0x10, 0x00, 0x14,
            0x00, 0x0A, // Priority
            0x00, 0x3C, // Weight
            0x13, 0xC4, // Port
            0x03, b's', b'i', b'p',
            0x07, b'e', b'x', b'a', b'm', b'p', b'l', b'e',
            0x03, b'c', b'o', b'm',
            0x00,
        ]
    }

    /// Get a packet with EDNS0 OPT record
    pub fn opt_record_edns() -> Vec<u8> {
        vec![
            // Header
            0xDD, 0xEE, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
            // Question
            0x07, b'e', b'x', b'a', b'm', b'p', b'l', b'e',
            0x03, b'c', b'o', b'm',
            0x00, 0x00, 0x01, 0x00, 0x01,
            // Answer
            0xC0, 0x0C, 0x00, 0x01, 0x00, 0x01,
            0x00, 0x00, 0x01, 0x2C, 0x00, 0x04,
            0x5D, 0xB8, 0xD8, 0x22,
            // Additional: OPT
            0x00, 0x00, 0x29, // Type: OPT
            0x10, 0x00, // Class: 4096
            0x00, 0x00, 0x00, 0x00, // TTL
            0x00, 0x00, // Data length
        ]
    }

    /// Get a malformed packet for error testing
    pub fn malformed_packet() -> Vec<u8> {
        vec![
            0x12, 0x34, 0x81, 0x80,
            0x00, 0x01, 0x00, 0x01,
            // Truncated - missing rest of packet
        ]
    }

    /// Get a packet with maximum compression
    pub fn compressed_packet() -> Vec<u8> {
        vec![
            // Header
            0xFF, 0xFF, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
            // Question: sub.example.com
            0x03, b's', b'u', b'b',
            0x07, b'e', b'x', b'a', b'm', b'p', b'l', b'e',
            0x03, b'c', b'o', b'm',
            0x00, 0x00, 0x01, 0x00, 0x01,
            // Answer 1: sub.example.com
            0xC0, 0x0C, 0x00, 0x01, 0x00, 0x01,
            0x00, 0x00, 0x01, 0x2C, 0x00, 0x04,
            0xC0, 0xA8, 0x00, 0x01,
            // Answer 2: example.com (compressed)
            0xC0, 0x10, 0x00, 0x01, 0x00, 0x01,
            0x00, 0x00, 0x01, 0x2C, 0x00, 0x04,
            0xC0, 0xA8, 0x00, 0x02,
            // Answer 3: www.example.com (partial compression)
            0x03, b'w', b'w', b'w',
            0xC0, 0x10, 0x00, 0x01, 0x00, 0x01,
            0x00, 0x00, 0x01, 0x2C, 0x00, 0x04,
            0xC0, 0xA8, 0x00, 0x03,
            // Answer 4: mail.sub.example.com (nested compression)
            0x04, b'm', b'a', b'i', b'l',
            0xC0, 0x0C, 0x00, 0x01, 0x00, 0x01,
            0x00, 0x00, 0x01, 0x2C, 0x00, 0x04,
            0xC0, 0xA8, 0x00, 0x04,
        ]
    }

    /// Get all test packets as a HashMap for easy iteration
    pub fn all_test_packets() -> HashMap<&'static str, Vec<u8>> {
        let mut packets = HashMap::new();
        packets.insert("a_record_google", Self::a_record_google());
        packets.insert("aaaa_record_ipv6", Self::aaaa_record_ipv6());
        packets.insert("mx_records", Self::mx_records());
        packets.insert("txt_record_spf", Self::txt_record_spf());
        packets.insert("ns_records", Self::ns_records());
        packets.insert("cname_record", Self::cname_record());
        packets.insert("soa_record", Self::soa_record());
        packets.insert("srv_record", Self::srv_record());
        packets.insert("opt_record_edns", Self::opt_record_edns());
        packets.insert("compressed_packet", Self::compressed_packet());
        packets
    }

    /// Generate a large TXT record packet for stress testing
    pub fn large_txt_packet() -> Vec<u8> {
        let mut packet = vec![
            // Header
            0xAA, 0xBB, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
            // Question
            0x04, b't', b'e', b's', b't',
            0x00, 0x00, 0x10, 0x00, 0x01,
            // Answer header
            0xC0, 0x0C, 0x00, 0x10, 0x00, 0x01,
            0x00, 0x00, 0x01, 0x2C,
        ];
        
        // Calculate how much data we can fit (max 450 bytes to stay under 512)
        let mut txt_data = Vec::new();
        let mut remaining = 450;
        
        while remaining > 1 {
            let chunk_size = std::cmp::min(255, remaining - 1);
            txt_data.push(chunk_size as u8);
            for _ in 0..chunk_size {
                txt_data.push(b'A');
            }
            remaining -= chunk_size + 1;
        }
        
        // Add data length
        packet.push(((txt_data.len() >> 8) & 0xFF) as u8);
        packet.push((txt_data.len() & 0xFF) as u8);
        
        // Add TXT data
        packet.extend(txt_data);
        
        packet
    }

    /// Generate a packet with multiple record types
    pub fn mixed_records_packet() -> Vec<u8> {
        vec![
            // Header
            0x12, 0x34, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
            // Question
            0x07, b'e', b'x', b'a', b'm', b'p', b'l', b'e',
            0x03, b'c', b'o', b'm',
            0x00, 0x00, 0xFF, 0x00, 0x01, // ANY query
            // Answer 1: A record
            0xC0, 0x0C, 0x00, 0x01, 0x00, 0x01,
            0x00, 0x00, 0x01, 0x2C, 0x00, 0x04,
            0x5D, 0xB8, 0xD8, 0x22,
            // Answer 2: AAAA record
            0xC0, 0x0C, 0x00, 0x1C, 0x00, 0x01,
            0x00, 0x00, 0x01, 0x2C, 0x00, 0x10,
            0x26, 0x06, 0x28, 0x00, 0x02, 0x20, 0x00, 0x01,
            0x02, 0x48, 0x18, 0x93, 0x25, 0xc8, 0x19, 0x46,
            // Answer 3: MX record
            0xC0, 0x0C, 0x00, 0x0F, 0x00, 0x01,
            0x00, 0x00, 0x01, 0x2C, 0x00, 0x09,
            0x00, 0x0A,
            0x04, b'm', b'a', b'i', b'l',
            0xC0, 0x0C,
            // Answer 4: TXT record
            0xC0, 0x0C, 0x00, 0x10, 0x00, 0x01,
            0x00, 0x00, 0x01, 0x2C, 0x00, 0x0E,
            0x0D, b'v', b'=', b's', b'p', b'f', b'1', b' ', b'~', b'a', b'l', b'l', b' ', b' ',
        ]
    }
}